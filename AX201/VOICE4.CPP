

#define _BUF_EMPTY_		0
#define _BUF_READY_		1
#define _EMPTY_SLOT_	-1
#define MAXBUFSIZE		16000
#define NUMBUFFER		10
#define QueueSize		(NUMBUFFER * 2)

union _long {
	unsigned int onelong;
	unsigned char bytes[4];
} Long;
struct _frag {
	short int status;
	unsigned char *address;
	unsigned int linear;
	unsigned short int length;
	unsigned short int bytes;
} Fragments[QueueSize];
int FragmentCount;

unsigned short int VoiceVolume=10;
short int FragmentQueue[QueueSize];   /* 음성을 출력할 데이타 블럭들의 큐 */
short int QueueFront=0,QueueRear=0;
static void (__interrupt __far *OldHandler)();	/* 사블 인터럽트 보관용 */
static void __interrupt __far SBLHandler();
char *VoiceBuffer[NUMBUFFER];
char TempBuffer[MAXBUFSIZE];
short int BufferCount,BufferPos;      /* 현재 재생중인 데이타 블럭의 번호와 위치  */
int Invalid=0;
int SBL_CommandError=0;


int VOC_IsQueueEmpty(void)
{
	return (QueueFront == QueueRear);
}

int VOC_IsQueueFull(void)
{
	return (((QueueFront + 1) % QueueSize) == QueueRear);
}

int VOC_QueueTop(void)
{
	if( VOC_IsQueueEmpty() ) return -1;
	else return FragmentQueue[QueueRear];
}

void VOC_InsertQueue(int fragnum)
{
	Fragments[fragnum].status = _BUF_READY_;
	FragmentQueue[QueueFront] = fragnum;
	QueueFront = ++QueueFront % QueueSize;
}

void VOC_DeleteQueue(void)
{
	Fragments[FragmentQueue[QueueRear]].status = _BUF_EMPTY_;
	Fragments[FragmentQueue[QueueRear]].bytes = 0;
	QueueRear = ++QueueRear % QueueSize;
}

unsigned short int VOC_GetDMACount(void)
{
	unsigned short int remainbytes;
	remainbytes = (unsigned short int) DMA_GetDMACounter( SBLDMAChannel );
	if( remainbytes == 0xFFFF ) remainbytes = 0;
	return remainbytes;
}

int VOC_sayDMAvoice(unsigned int address,unsigned short int length)
{
    DMA_DisableDREQ(SBLDMAChannel);     /*  먼저 DMA를 중지시킨다.  */
	if( DMA_Run( address, length, SBLDMAChannel, 1 ) != 0 ) {
                                        /*  DMA를 가동시키고 에러가 나면
                                            복귀한다.               */
		VoiceFlag = VOICE_IDLE;
		return -1;
	}
    SBL_Command( DMA_8BIT_DAC );        /* 8비트 DMA DAC 명령 */
    SBL_Command( length & 0xff );       /* 음성길이 설정 */
	SBL_Command( length >> 8 );
	VoiceFlag = VOICE_BUSY;
	return 0;
}

void VOC_mixvoice(unsigned char *dst,unsigned char *src,unsigned short int length)
{
	unsigned int i;
	short int d1;
	for(i=0;i<length;i++,dst++,src++) {
		d1 = (short int) *dst + (short int) *src;
		d1 >>= 1;
        *dst = d1;          /*  두 데이타를 더하고 다시 2로 나눈 값을
                                저장한다.   */
	}
}

void VOC_savedata(unsigned char *buffer,unsigned short int bytes)
{
	unsigned short int bufpos,gap;
	bufpos = 0;
    while( bytes ) {    /*  저장해야 할 데이타가 있는 동안  */
		gap = Fragments[BufferCount].length - BufferPos;
                        /*  현재 데이타 블럭의 남은 공간을 계산 */
        if( bytes > gap ) {     /*  남은 공간이 더 적다면       */
			VOC_mixvoice(Fragments[BufferCount].address + BufferPos,buffer + bufpos, gap );

			Fragments[BufferCount].bytes = Fragments[BufferCount].length;
                                /*  남은 공간만큼만 현재 블럭에 추가    */
			switch( Fragments[BufferCount].status ) {
			case _BUF_EMPTY_:
				VOC_InsertQueue( BufferCount );
                                /*  현재 블럭이 큐에 없는 경우 추가     */
				break;
			case _BUF_READY_:
				if( VOC_QueueTop() == BufferCount ) {
					SBL_Command( HALT_DMA );
					VOC_sayDMAvoice( Fragments[BufferCount].linear + BufferPos,
						gap );
                }               /*  현재 블럭이 큐에 있었다면, DMA 전송량이
                                    바뀌었으므로 중지하고 다시 전송한다.    */
			}
			BufferPos = 0;
			BufferCount = ++BufferCount % FragmentCount;
                                /*  다음 데이타 블럭을 가리킨다.    */
            bytes -= gap, bufpos += gap;
		}
        else {                  /*  남은 공간이 충분하다면          */
			VOC_mixvoice( Fragments[BufferCount].address + BufferPos,
				buffer + bufpos, bytes );
                                /*  모두 저장한다.                  */
			switch( Fragments[BufferCount].status ) {
			case _BUF_EMPTY_:
				VOC_InsertQueue( BufferCount );
				break;
			case _BUF_READY_:
				if( VOC_QueueTop() == BufferCount ) {
					SBL_Command( HALT_DMA );
					VOC_sayDMAvoice( Fragments[BufferCount].linear + BufferPos,
						bytes );
				}
			}
			BufferPos += bytes;
			if( Fragments[BufferCount].bytes < BufferPos )
				Fragments[BufferCount].bytes = BufferPos;
			bytes = 0;
		}
	}
	if( Fragments[BufferCount].status == _BUF_EMPTY_ )
        VOC_InsertQueue( BufferCount );     /*  현재 데이타 블럭이 큐에
                                            존재하지 않으면 추가한다.   */
	if( BufferPos >= Fragments[BufferCount].length ) {
		BufferPos = 0;
		BufferCount = ++BufferCount % FragmentCount;
    }                                       /*  데이타 블럭의 끝이면 다음
                                            데이타 블럭을 가리키도록 한다.  */
}

unsigned char VOC_readbyte(int fd)
{
	unsigned char onebyte;
	onebyte=read(fd,&onebyte,1);
	return onebyte;
}

/*
**  VOC 화일에서 음성 데이타만을 찾아내어 음성 데이타 블럭에 저장한다.
*/
int VOC_readvoice(char *filename)
{
	short int ended;
int fd;
	unsigned short int bytes;
	unsigned int blocklength;
	unsigned char command;
	fd = open( filename,O_RDONLY);
Long.onelong=filelength(fd);
	if( fd == -1 ) return -1;
	bytes = read(fd,TempBuffer, 22 );
Long.onelong-=22;
	lseek( fd, *(unsigned int *)(TempBuffer+20), SEEK_SET );
	ended = 0;
	while( !ended ) {
		command = VOC_readbyte( fd );
		switch( command ) {
		case 0:         /*      End of voice file..     */
			ended = 1;
			break;
		case 1:         /*      Voice data..            */
		case 2:         /*      Continuous...           */
			Long.bytes[0] = VOC_readbyte( fd );
			Long.bytes[1] = VOC_readbyte( fd );
			Long.bytes[2] = VOC_readbyte( fd );
			Long.bytes[3] = 0;
Long.onelong-=3;
			if( command == 1 ) {
				Long.onelong -= 2;			/*      exclude 2 byte  */
				VOC_readbyte( fd );         /*      Sampling Rate   */
				VOC_readbyte( fd );         /*      Packe Mode.     */
			}
			while( Long.onelong ) {
				if( Long.onelong > MAXBUFSIZE )
					bytes = read(fd,TempBuffer, MAXBUFSIZE);
				else bytes = read( fd,TempBuffer, Long.onelong );
				VOC_savedata((unsigned char *)TempBuffer, bytes );
				Long.onelong -= bytes;
			}
			break;
		case 3:         /*      Silent voices..         */
		case 4:         /*      Mark...                 */
		case 5:         /*      String..                */
		case 6:         /*      Block Start..           */
		case 7:         /*      Block End..             */
			close( fd );
			return -1;
		}
	}
	close( fd );
	return 0;
}

int VOC_Play(char *filename)
{
	if( VoiceHardWare == NO_VOICE ) return -1;
	if( VoiceFlag == VOICE_IDLE ) BufferCount = 0, BufferPos = 0;
        /*  현재 음성이 출력중이 아니라면 처음 데이타 블럭을 가리킨다.  */
	else {
		BufferCount = VOC_QueueTop();
		BufferPos = VOC_GetDMACount();
	}

	if( VOC_readvoice( filename ) == -1 ) return -1;
/*
	if( VoiceFlag == VOICE_IDLE ) {
		VOC_sayDMAvoice( Fragments[FragmentQueue[QueueRear]].linear,
			Fragments[FragmentQueue[QueueRear]].bytes );
	}*/
	return 0;
}

static void  __interrupt __far SBLHandler(void)
{
	short int i,j;
	_disable();
    inp( SBLBaseIO + 0xe );     /*  acknowledge interrupt */
    SBL_Command( HALT_DMA );        /*  DMA를 중지하도록 한다.  */
    j = VOC_QueueTop();             /*  큐에서 출력중이었던 데이타 블럭     */
    VOC_DeleteQueue();              /*  전송이 끝난 블럭을 제거한다.        */
	if( VOC_IsQueueEmpty() ) VoiceFlag = VOICE_IDLE;
                                    /*  더 이상 블럭이 없으면 종료          */
	else {
		i = VOC_QueueTop();
		VOC_sayDMAvoice( Fragments[i].linear, Fragments[i].bytes );
                                    /*  출력해야 할 데이타 블럭을 재생      */
	}
	memset( Fragments[j].address, 0, Fragments[j].length );
                                    /*  전송이 끝난던 블럭을 0으로 채워준다.
                                        0으로 채우지 않으면 나중에 음성을
                                        섞을 때, 잡음이 섞일 수도 있다.     */
    outp( 0x20, 0x20 );         /*  8259A PIC에게 하드웨어 인터럽트가
                                        종료하였음을 알린다.                */
	_enable();
}

int VOC_Silent(void)
{
	if( VoiceHardWare == NO_VOICE || VoiceFlag == VOICE_IDLE ) return -1;
	SBL_Command( HALT_DMA );
	VoiceFlag = VOICE_IDLE;
	return 0;
}

void VOC_SetSampleRate(unsigned short int sr)
{
	unsigned char index;
    SBL_Command( FREQ_DIVISER );        /*  사블 주파수 분주값 설정 */
	index = (unsigned char) (256 - 1000000 / sr);
    SBL_Command( index );
}

void SBL_PCMVolume(unsigned short int vl,unsigned short int vr)
{
	short int i,vol;
	if( vl > 15 ) vl = 15;
	if( vr > 15 ) vr = 15;
	if( VoiceHardWare == NO_VOICE ) return;
	setSBLProMixer( SBLPRO_VOICE_VOLUME, vr, vl );

}

void VOC_calcaddr(void)
{
	short int i;
	int page,add16;
	int physical;
	unsigned int Address[2];
	unsigned short int Length[2];
	unsigned short int segment,offset;
	struct _frag *fragment;
	for(FragmentCount=i=0;i<NUMBUFFER;i++) {
		physical = ((int)(FP_OFF(VoiceBuffer[i]))) +
			(((int)(FP_SEG(VoiceBuffer[i]))) << 4);
		page  = ( physical & 0x00FF0000 );
		add16 = ( physical & 0x0000FFFF );
		Address[0] = physical;
		Length[0] = MAXBUFSIZE;
		fragment = &Fragments[FragmentCount];
		if( add16 + MAXBUFSIZE > 0x10000 )
		{
			Address[0] = page + 0x10000;
			Length[0] = ( (physical + MAXBUFSIZE) & 0xFFFF );
			Length[1] = MAXBUFSIZE - Length[0];
			Address[1] = physical;
			fragment->status = _BUF_EMPTY_;
			segment = Address[1] >> 4;
			offset = Address[1] & 0x000F;
			fragment->address =(unsigned char*)MK_FP( segment, offset );
			fragment->linear = Address[1];
			fragment->length = Length[1];
			fragment->bytes = 0;
			FragmentCount++, fragment++;
		}
		fragment->status = _BUF_EMPTY_;
		segment = Address[0] >> 4;
		offset = Address[0] & 0x000F;
		fragment->address =(unsigned char*) MK_FP( segment, offset );
		fragment->linear = Address[0];
		fragment->length = Length[0];
		fragment->bytes = 0;
		FragmentCount++;
	}
}

int VOC_getmemory(void)
{
	int i,flag;
	for(i=flag=0;i<NUMBUFFER;i++) {
		VoiceBuffer[i] = (char *) malloc( MAXBUFSIZE );
		if( VoiceBuffer[i] == NULL ) flag++;
		else memset( VoiceBuffer[i], 0, MAXBUFSIZE );
	}
    if( flag ) {
		for(i=0;i<NUMBUFFER;i++)
			if( VoiceBuffer[i] ) free( VoiceBuffer[i] );
		return -1;
	}
	return 0;
}

int VOC_Init(void)
{
  if( SBL_AutoDetect() == -1 ) return -1;
  if( VOC_getmemory() ) return -1;

 _disable();
 OldHandler =_dos_getvect( 0x08 + SBLIRQ );
 _dos_setvect( 0x08 + SBLIRQ, SBLHandler );
 outp( 0x21, inp( 0x21 ) & ~(1 << SBLIRQ) );
 VOC_SetSampleRate( SampleRate );
 _enable();
 VoiceHardWare = SOUNDBLASTER;
 VOC_SetVolume( VoiceVolume );
 VOC_calcaddr();
 VOC_SetSampleRate( 8000 );
 SBL_Speaker( 1 );
 return 0;
}

void VOC_Close(void)
{
	int i;
	if( VoiceHardWare == NO_VOICE ) return;
    SBL_Speaker( 0 );       /* 사블 스피커를 끈다. */
	for(i=0;i<NUMBUFFER;i++) {
		if( VoiceBuffer[i] ) free( VoiceBuffer[i] );
        /*  메모리 해제     */
	}
	_disable();
    _dos_setvect( 0x08 + SBLIRQ, OldHandler );   /* 인터럽트 벡터를 되돌린다. */
	if( SBLIRQ != 2 ) outp( 0x21, inp( 0x21 ) | (1 << SBLIRQ) );
	_enable();
	VoiceFlag = VOICE_IDLE;
}

void SBL_Speaker(unsigned char flag)
{
	if( flag ) SBL_Command( SBL_SPEAKER_ON );
	else SBL_Command( SBL_SPEAKER_OFF );
}

int SBL_Reset(short int BaseIO)
{
	short int i,j;
    outp( BaseIO + SBL_RESET, SBL_RESET_CMD );
        /* 사블에 리셑 명령어를 보낸다. */
	for(i=0;i<100;i++) j = inp( BaseIO + SBL_RESET );
    outp( BaseIO + SBL_RESET, 0 );
        /* 사블 리셑 */
	for(i=0;i<1024;i++) {
		if( inp( BaseIO + SBL_DATA_AVAIL ) & 0x80 ) {
			/* 사블 인식값 AAh가 읽히는지 확인 한다. */
			for(j=0;j<1024;j++) {
				if( inp( BaseIO + SBL_READ_DATA ) == 0xAA ) return 1;
			}
			return -1;
		}
	}
	return -1;
}


/*
**  SBL_sendcommand 를 이용하여 사블에 명령어를 보낸다.
*/
SBL_Command(unsigned char D)
{
	if( SBL_sendcommand( D ) < 0 ) SBL_CommandError++;
	return 1;
}

void __interrupt __far _int2(void)
{
	_disable();
	inp( SBLBaseIO + 0xe );		/* acknowledge interrupt */
	outp( 0x20, 0x20 );
	SBLIRQ = 2;
 _enable();
}
	void __interrupt __far _int5(void)
 {
	_disable();
	inp( SBLBaseIO + 0xe );		/* acknowledge interrupt */
	outp( 0x20, 0x20 );
	SBLIRQ = 5;
	_enable();
}

/* 사블 인터럽트 번호를 찾기위한 루틴 */
void __interrupt __far _int7(void)
{
	_disable();
	inp( SBLBaseIO + 0xe );		/* acknowledge interrupt */
	outp( 0x20, 0x20 );
	SBLIRQ = 7;
	_enable();
}

int SBL_AutoDetect(void)
{
	short int i,flag;
	short int old8259mask;
	void __interrupt __far (*Oldint2)();	/* 인터럽트 2 보관용 */
	void __interrupt __far (*Oldint5)();	/* 인터럽트 5 보관용 */
	void __interrupt __far (*Oldint7)();	/* 인터럽트 7 보관용 */

	VoiceHardWare = SOUNDBLASTER;
	SBLBaseIO = SBLDMAChannel = SBLIRQ = -1;
/* 220h 에서 270h 까지 사블을 리셑시키면서 BaseIO번지를 찾는다. */
	flag = 0;
	for(i=0x210;i<=0x270;i+=0x10) {
		if( SBL_Reset( i ) == 1 ) {
			flag = 1;
			SBLBaseIO = i;
			break;
		}
	}
	if( flag == 0 ) return -1;
	Oldint2 = _dos_getvect( 0x8 + 2 );
	_dos_setvect( 0x8 + 2, _int2 );
	Oldint5 = _dos_getvect( 0x8 + 5 );
	_dos_setvect( 0x8 + 5, _int5 );
	Oldint7 = _dos_getvect( 0x8 + 7 );
	_dos_setvect( 0x8 + 7, _int7 );
/* 사블이 사용하는 IRQ 2,5,7의 인터럽트를 가능하게 한다. */
	old8259mask = inp( 0x21 );
	outp( 0x21, 0x5b );	/* 0101 1011 */
/* 인터럽트를 찾기 위해서 더미 인터럽트를 발생시키는 명령을 보낸다. */
	SBL_Command( 0xf2 );	/* interrupt request */
	waitmSec( 400 );		/* 인터럽트가 발생할때까지 400 밀리초 기다린다. */
	SBL_Speaker( 0 );		/* speaker off */
	VOC_SetSampleRate( 8000 );
/* DMA 채널을 찾기위해서 사블이 사용하는 DMA 채널 1,3을 이용 음성 발생 */
	DMA_Run( 0x30000L, 100, 1, 1 );
	DMA_Run( 0x30000L, 100, 3, 1 );
	SBL_Command( DMA_8BIT_DAC );
	SBL_Command( 2 );
	SBL_Command( 0 );
	waitmSec( 400 );
/* 설치된 DMA 채널의 카운터값은 3 감소한다. */
	if( DMA_GetDMACounter( 3 ) == 97 ) SBLDMAChannel = 3;
	if( DMA_GetDMACounter( 1 ) == 97 ) SBLDMAChannel = 1;
	SBL_Command( HALT_DMA );
/* 인터럽트 복귀 */
	outp( 0x21, old8259mask );
	_dos_setvect( 0x8 + 2, Oldint2 );
	_dos_setvect( 0x8 + 5, Oldint5 );
	_dos_setvect( 0x8 + 7, Oldint7 );
	if( (SBLDMAChannel != -1) && (SBLIRQ != -1) ) return 1;
	else return -1;
}

void waitmSec(unsigned short int mSec)
{
	int tick;
	tick = (32768L * (int) mSec) / 1000L;
	for(;tick>0;tick--) {
		while( inp( 0x61 ) & 0x10 ) ;
		while( !(inp( 0x61 ) & 0x10) ) ;
	}
}

void VOC_SetVolume(unsigned short int vol)
{
	if( vol > 15 ) return;
	SBL_PCMVolume( vol, vol );
	VoiceVolume = vol;
}

unsigned int VOC_GetVolume(void)
{
	return VoiceVolume;
}
